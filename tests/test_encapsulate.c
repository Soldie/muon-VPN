/*
 * encapsulate.c - test encapsulate and decapsulate
 *
 * Copyright (C) 2014 - 2016, Xiaoxiao <i@pxx.io>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <sodium.h>

#include "../src/crypto.h"
#include "../src/encapsulate.h"


int main()
{
    crypto_init("8556085d7ff5655a5e09a385c152ea2a");

    const int mtu = 1452;

    pbuf_t pbuf;
    int n;

    /*
    // these code generate test data used bellow
    for (int i = 0; i < 1024; i++)
    {
        pbuf.payload[i] = (i % 2) ? 0x55u : 0xaau;
    }
    pbuf.len = 1024;
    pbuf.flag = 0x0000;
    pbuf.ack = 0;
    n = encapsulate(0, &pbuf, mtu);
    printf("%d\n", n);
    for (int i = 0; i < n; i++)
    {
        printf("\\x%02x", ((uint8_t *)&pbuf)[i]);
    }
    printf("\n");

    for (int i = 0, c = 0; i < 512; i++)
    {
        c = (32771 * c + 10007) % 65537;
        pbuf.payload[i] = (c & 0xffu);
    }
    pbuf.len = 512;
    pbuf.flag = 0x0000;
    pbuf.ack = 0;
    n = encapsulate(0, &pbuf, mtu);
    printf("%d\n", n);
    for (int i = 0; i < n; i++)
    {
        printf("\\x%02x", ((uint8_t *)&pbuf)[i]);
    }
    printf("\n");
    */

    uint8_t test1[] =
        "\x52\xe8\x5c\x32\xbf\xc6\xaa\x07\x1f\xd3\x66\xff\x54\x09\xff\x17\x58\xc6\x87\x9c\x5d\xa7\x7a\x4c\x9c\xfe\xc5\xae\xd9\xda\x7e\x31\x3f\x2c\xe4";
    memcpy(&pbuf, test1, sizeof(test1));
    n = decapsulate(0, &pbuf, sizeof(test1));
    assert(n == 1024);
    assert(pbuf.len == 1024);
    for (int i = 0; i < n; i++)
    {
        assert(pbuf.payload[i] == ((i % 2) ? 0x55u : 0xaau));
    }

    uint8_t test2[] =
        "\xde\x6d\x24\x65\x68\x7d\xe3\x25\x3c\x65\x80\xc9\xf8\x06\xec\xa5\x55\x5f\xb8\x81\xa9\x2c\x8d\xd7\xdf\xc0\x26\xba\xcf\xe7\xa5\xa0\x6e\x25\x61\x89\x68\x36\x71\x8c\xa8\x2f\xa9\x4f\x05\x5a\x33\x39\x78\xd6\x7d\xd0\x8c\x65\xdd\x95\x98\x33\x12\xb5\x04\x94\xe1\xb0\xff\x26\x6d\xfe\xb0\x2a\x5d\xbc\xae\x0a\xd1\x53\x24\x19\x90\xb0\x98\x7f\xf8\x72\x17\x93\x1b\xf0\xcf\xcf\x2c\x35\x69\x35\x94\xc8\xda\xfa\x31\xf9\x4d\x96\x0d\x41\x3f\x0b\x31\x9b\x3f\x05\x2d\xd4\xa9\x8a\x09\x99\x49\x23\xd5\x6c\xc5\x41\x3d\xe0\xf6\x26\xd7\x8a\xa9\x43\x8a\x4a\x98\x9b\x77\x2d\x0e\xd6\xba\x64\x3b\x15\x7e\x79\x93\xe0\x7c\x03\xde\xf3\x4f\x16\xc0\x76\x5d\x24\x01\x24\x2b\xc9\xf8\x38\xb0\x12\xea\x1c\x1d\x51\x0d\xf7\xb5\x48\xa4\xd7\xc5\xdd\x2f\xbd\xb2\xa0\xaf\x54\x65\x7f\x61\xcf\xf8\x60\xc0\xf1\xb1\xa5\x81\xa9\xbe\xa6\x7a\x09\xa1\xce\xde\xf1\x4e\xed\x5c\xd6\xe3\xab\xe5\x53\x5f\xa3\x77\x9c\xcc\x63\xee\x81\xfb\x43\xd6\x91\x20\xf2\x4b\x90\x89\x4e\xc2\x24\x56\xdb\x00\x10\xdd\x88\xf7\x59\x68\x83\x94\xcb\x6e\xf0\x3c\xcf\x6e\xe0\x3b\x8f\x46\xaf\xa8\xc5\xf7\x1e\xf1\x01\x33\xab\x9d\x08\xd4\x25\xf3\x27\x9c\xb9\x8b\x19\xac\xbb\xc9\xdc\x0f\x71\xb5\x08\x16\xd8\xd0\x44\x77\x86\x5f\xe7\x96\x45\xe1\xfc\xcb\x81\x83\x3e\xeb\xc9\xd4\x86\x80\x90\xd6\x82\xee\x92\x98\xda\x1d\xee\x59\x02\x54\x28\x8e\x2c\xc3\xe0\x6b\x09\xe2\x9a\xca\x0a\x17\xcb\xdb\x69\xb1\x06\x22\xba\xd7\xc5\x81\xb9\x76\x62\xc9\x9c\x08\x5c\xeb\x49\x5f\x3e\xea\x20\x6e\x7a\xc6\x15\xc1\x60\xa9\x09\x22\xba\x08\xac\xe9\xf2\xd0\x60\xf4\xac\x6a\xf5\xaf\x23\xd1\xa1\xfa\x50\x2d\xc6\x54\xe3\x80\x0b\x94\x9f\xc8\xe3\xa7\xbe\x5c\xce\x02\xcd\x5a\x85\xa0\xdd\x39\x50\x4a\x7c\x82\x80\xdb\xfb\xe8\xc5\x10\x3c\xea\xaf\x0c\x34\x27\xc2\x87\x44\x0c\x60\xf3\x91\xb4\xd3\xe8\xa7\x9e\xeb\x53\x1c\x82\x06\xd0\x36\x52\x14\x6c\x57\xff\xef\xe5\x49\x8b\x79\xe9\xb7\x32\x71\x8e\xc3\xbe\x2a\xab\x0a\x89\x95\x11\x09\x4d\xfc\x32\x65\x58\xbe\xc3\xed\x47\xea\x93\xb4\x3e\x8e\xc8\x0c\x80\x7c\xa0\x7c\xed\xe7\x08\xbd\x00\xf6\xc3\xd1\xe0\xc9\x35\x02\x11\x28\x10\xc8\x81\xb9\x20\xa1\xf7\x1d\x7b\x5b\xc7\x10\x11\xdf\x5a\x50\xee\x14\x26\xa9\xe4\xa4\x00\x38\x8c\x01\xcf\xac\xad\x97\x5b\x06\x81\x81\x00\xc5\x39\x29\x27\x07\x94\x44\x7f\xb9\x9c\x0d\xd5\xbe\x7d\x25\x37\xa3\x52\xfa\xbd\x19\x17\xe6\x8d\x1d\xbb\x95\x20\x0e\x2d\xaf\x58\xa5\x11\x3c\xce\x87\xc6\xc0\x29\x51\x68\x79\xa8\x94\x7d\xb8\x5d\xf0\x44\x0d\xea\x51\x0d\x85\x84\xb4\x16\x43\x85\x52\xd3\x34\x47\xad\x4e\x02\x7b\xc7\x51\x05\xdc\x0d\xc6\x11\x3a\xed\x4b\xbd\xa4\x4e\xa9\x8a\x5f\x34\xef\x07\x10\x76\xcf\xb4\xc1\xdb\x85\x87\x64\x3e\x89\x1e\x33\x4c\x38\x3f\xfa\x7f\xd0\x47\xfa\xbe\x02\x96\x8d\xe2\x69\x5d\x39\xea\x43\xa8\x32\x4f\x12\xcb\xf3\x90\xf6\x4b\xfc\x45\x8e\xd7\xde\xd4\x28\xe3\x94\xac\x53\x7e\x8a\x13\x22\x81\xec\x85\xaf\x6b\x99\x45\x6e\x2b\x62\xeb\x5a\x06\x69\x24\x7f\xdb\x7c\x07\xe1\x70\x86\x3a\x57\x10\x91\x2c\x5b\xc1\x44\x7a\xec\x27\xb6\xc0\x05\x6a\x40\x5b\xee\xcb\xcb\x89\xbe\xce\xb6\x32\x2a\x65\x85\xc6\x1d\xff\x6d\xf4\x73\x21\xa4\x99\xda\x02\x3f\x21\x4d\xd4\x1d\x2b\x92\xbd\xb7\x5d\x76\x61\xf6\x9b\xbd\xaf\x50\x50\xbd\x4d\x78\x1a\x50\x7d\x7d\x6b\x22\x80\xb6\xc1\x76\xde\x18\xed\x99\xc3\x48\x7f\xc7\x55\xe5\x21\x0f\x22\xf9\x00\xa4\xc4\xd8\xa4\x61\x3d\xa5\x55\xa8\x1a\xe1\x4d\x35\xfa\xb9\x95\xda\xaf\xac\x51\x31\xf7\xc6\x59\x90\x90\x8d\x4f\xdf\xac\x49\xc7\xf3\x53\x1c\x02\x65\xd6\x4d\x68\xf6\xef\xd2\x0e\x50\xc3\xf1\x8a\xa9\x0b\xd5\xcb\xcf\xc6\x75\x0e\xae\x97\x88\xf4\x24\x98\x2b\xce\x40\x6d\x58\x20\x60\xe8\xcb\x75\x87\x37\xd9\x32\x4b\x06\xfd\x5f\x91\x35\x6e\x9f\x5a\x86\xd2\xdc\x91\xf6\xa9\x93\x0d\x32\x22\xb3\x40\xe3\xd4\xa3\x4a\xb0\x73\x17\xbf\x7c\x98\x33\x6f\x38\xce\x52\xc0\x7e\xed\xf1\x77\x3f\x84\x30\x43\x96\xaf\x9b\x1d\xac\x3e\xd2\x0d\xc1\x7d\x89\xd0\x77\x45\xa6\x04\x13\x9f\xb6\x51\xcc\xe6\x75\xe3\x89\x76";
    memcpy(&pbuf, test2, sizeof(test2));
    n = decapsulate(0, &pbuf, sizeof(test2));
    assert(n == 512);
    assert(pbuf.len == 512);
    for (int i = 0, c = 0; i < n; i++)
    {
        c = (32771 * c + 10007) % 65537;
        assert((pbuf.payload[i]) == (c & 0xffu));
    }

    for (int len = 0; len <= mtu; len++)
    {
        for (int data = 0; data <=2; data++)
        {
            for (int j = 0; j < len; j++)
            {
                if (data == 0)
                {
                    pbuf.payload[j] = (uint8_t)(randombytes_uniform(256));
                }
                else if (data == 1)
                {
                    pbuf.payload[j] = (uint8_t)(j & 0xffU);
                }
                else
                {
                    pbuf.payload[j] = (uint8_t)(len & 0xffU);
                }
            }
            pbuf.len = len;
            pbuf.flag = 0x0000;
            pbuf.ack = 0;

            pbuf_t copy;
            copy.ack = pbuf.ack;
            copy.flag = pbuf.flag;
            copy.len = pbuf.len;
            memcpy(copy.payload, pbuf.payload, pbuf.len);

            n = encapsulate(0, &copy, mtu);
            assert(n <= mtu + PAYLOAD_OFFSET);

            n = decapsulate(0, &copy, n);
            assert(n >= 0);
            assert(copy.len == pbuf.len);
            assert(memcmp(copy.payload, pbuf.payload, copy.len) == 0);
        }
    }
    return 0;
}
