/*
 * encapsulate.c - test encapsulate and decapsulate
 *
 * Copyright (C) 2014 - 2016, Xiaoxiao <i@pxx.io>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <sodium.h>

#include "../src/crypto.h"
#include "../src/encapsulate.h"


int main()
{
    crypto_init("8556085d7ff5655a5e09a385c152ea2a");

    const int mtu = 1452;

    pbuf_t pbuf;
    int n;

    // these code generate test data used bellow
    /*
    for (int i = 0; i < 1024; i++)
    {
        pbuf.payload[i] = (i % 2) ? 0x55u : 0xaau;
    }
    pbuf.len = 1024;
    pbuf.flag = 0x0000;
    pbuf.ack = 0;
    n = encapsulate(&pbuf, mtu);
    printf("%d\n", n);
    for (int i = 0; i < n; i++)
    {
        printf("\\x%02x", ((uint8_t *)&pbuf)[i]);
    }
    printf("\n");

    for (int i = 0, c = 0; i < 512; i++)
    {
        c = (32771 * c + 10007) % 65537;
        pbuf.payload[i] = (c & 0xffu);
    }
    pbuf.len = 512;
    pbuf.flag = 0x0000;
    pbuf.ack = 0;
    n = encapsulate(&pbuf, mtu);
    printf("%d\n", n);
    for (int i = 0; i < n; i++)
    {
        printf("\\x%02x", ((uint8_t *)&pbuf)[i]);
    }
    printf("\n");
    */

    uint8_t test1[] =
        "\x75\xfd\x23\xb0\x0f\x47\xa3\x05\x28\x8f\x58\xe8\x62\xca\xf2\x2e"
        "\x91\x95\xd5\x47\x6a\x73\xab\xf2\x0c\x3c\xa9\x3d\x90\x85\x99\x0d"
        "\x27\xd7\x90";
    memcpy(&pbuf, test1, sizeof(test1));
    n = decapsulate(&pbuf, sizeof(test1));
    assert(n == 1024);
    assert(pbuf.len == 1024);
    for (int i = 0; i < n; i++)
    {
        assert(pbuf.payload[i] == ((i % 2) ? 0x55u : 0xaau));
    }

    uint8_t test2[] =
        "\xad\x81\x89\xd6\x95\xd9\x9a\x39\x87\x4d\x13\x87\xf3\x5e\x47\x4d"
        "\x5f\x61\x96\x8a\x88\xc8\xb7\x07\xc1\x6d\xff\x8f\x78\x7c\xe1\xe4"
        "\xe6\xaf\x42\x4c\x5c\xe3\x86\x49\xea\xe7\x0d\x86\xba\x11\x91\x8c"
        "\xc2\xae\x5a\x8c\x94\xcb\x89\x7b\xe4\xc6\x5c\x22\xb8\xd5\x55\xcd"
        "\xbf\x4c\xe8\x40\xdf\xd6\xdc\x6e\xe8\xb4\x51\x0f\x7e\x08\xe2\x3e"
        "\x0a\x42\x0a\x52\x2b\xde\x77\x6e\x9c\x0f\xcd\xf1\xcf\x6b\x24\x59"
        "\xbf\xa7\x88\xf2\xfc\xa2\x7f\x11\xc2\x82\x72\x5b\x5c\x14\xbd\x3c"
        "\x21\x1b\xb7\x0e\x1b\x7a\x6b\x17\xf6\x6a\xa7\x58\x1e\x9d\xba\xed"
        "\x38\x23\x7c\x8c\x4a\xf4\x5b\x9b\x8a\x76\x70\x7b\x4a\xd4\x83\x2d"
        "\xdb\x9f\x50\xb8\x4d\x2b\xce\x33\x66\x4e\xa6\xc2\x82\xb8\xcb\x0b"
        "\xb4\xef\x84\x13\x73\x5f\xc9\xe7\xb5\x65\xfb\x9c\x9f\x1c\xac\xaf"
        "\x42\xfe\xaf\x9c\x84\xe3\x2c\xb6\x2f\x27\xa3\xa5\x59\x6e\x97\x13"
        "\x29\xe0\x5e\xb4\x0a\xf3\x8d\x7c\x1c\x89\x69\xb1\x44\x24\xdd\xe3"
        "\xb1\xc3\x58\x05\x5f\x08\xac\xa3\xd2\xef\xa3\xea\xf8\xd3\x1f\xbb"
        "\x22\x38\x77\x19\xbd\xcd\x09\xfb\xda\x2e\x1a\xb0\x94\x37\xd3\x35"
        "\x25\x1d\xf3\x3b\x52\xce\x6f\x2c\xf9\xc4\xb9\x1b\x1d\x07\xae\xf8"
        "\x31\x7e\xdf\x6c\xaf\xab\xe0\x05\xbf\x0b\x8c\x45\x6c\xe5\x65\x28"
        "\xea\xd9\xf0\xe5\x28\x01\x7a\x50\xbe\x43\x66\x4d\x62\x6c\x66\x04"
        "\x1d\x1b\xef\x2e\x95\xce\xe1\xda\xf8\x99\xe4\x62\xe0\x53\xd2\x7b"
        "\x63\x2e\x90\xf7\xe0\x13\xcf\x75\x74\xcd\x43\x5b\xbe\xba\x34\xd0"
        "\xc9\x77\x86\xaf\x2e\x1f\x0a\x4e\x9b\xaa\x0b\xa7\x81\xc0\xbe\xdd"
        "\x3d\x69\x40\xbd\x6d\x23\x56\x29\xc8\xd7\xef\x3a\xa2\xb1\xed\xed"
        "\xd4\x43\xa4\xd3\x0b\xc9\xd5\xf4\xaa\x49\x44\xcc\x67\xc2\xcf\x0f"
        "\xc1\x3f\xc7\xb9\x0e\x1e\xa7\x59\x9e\x06\x97\xfe\x4a\x7f\xd2\x1c"
        "\x7c\x30\xda\x0e\x3a\xa3\xde\xae\x61\xa5\x14\x21\x8d\x12\x9f\xac"
        "\x49\x87\x0a\x34\xe8\x8b\xaf\xbd\x43\x65\xc5\x77\x21\x50\x0c\xc0"
        "\xd0\x16\x24\x0a\x23\x63\x20\xcc\x2b\x60\x1c\x88\xb2\x29\xd1\x88"
        "\x9a\x47\xe1\x59\xf7\x5e\x4c\x32\xf7\xb9\xdb\x0f\x6e\x0d\xd8\x50"
        "\xe7\x35\x9b\xdf\x18\x83\xa1\x8d\xe9\xaa\xef\x21\x14\x75\x08\x99"
        "\x80\x60\xe2\x31\x1c\x6c\x98\xf9\x2c\x1f\x92\xdd\x91\xc6\x03\x31"
        "\x31\x6e\x7a\x68\x59\x29\xa4\x96\x6d\x49\x7b\xb7\x35\x00\x54\x52"
        "\xc6\xec\x7b\x84\x3a\x69\xee\x19\xc1\x6f\x95\x19\x48\x51\xb3\xf5"
        "\xa3\x36\x27\x99\x25\x33\xca\x16\x4b\xfc\x64\x56\x83\x02\xba\xa6"
        "\x89\x3b\x1a\x1e\x37\x49\x9e\xd7\x50\x3f\x02\x11\x34\x96\x8c\x08"
        "\x6b\x58\x45\xc7\x74\x51\xe8\x52\x7e\x16\xc7\xd4\xe5\xe6\x88\x5e"
        "\xfb\x76\x07\x2b\xac\x8a\x3b\x47\x67\x0d\xb7\xf9\x4f\x78\x2b\x6a"
        "\x73\x2a\xfa\xa2\x42\x17\x83\xb7\xe6\xf8\xb8\x13\x43\x31\x89\x50"
        "\x3a\xa5\x42\x08\x81\x6e\x83\xea\x8f\xdc\xcb\x90\x1c\x2d\x79\xd7"
        "\x15\xb1\x34\x9b\x2c\x21\x39\xf0\x35\x82\xdf\x83\xe4\xf9\x36\xd1"
        "\x2c\x5a\xa8\x82\x23\xd3\xab\xf0\x07\x03\x24\xc3\x27\x0d\xaf\xe5"
        "\x16\x13\x5c\xbc\x6e\x6d\x58\xb1\x4d\x2e\x3d\xfe\xd4\xa0\xfc\x14"
        "\x4b\xc7\x56\xe5\x15\xc3\x9a\x5f\x7f\x8c\x8c\x5a\x5d\xc0\xdb\x79"
        "\x17\xb7\xf8\xb8\x1e\xf6\x77\xb3\x50\xb2\xbd\x2f\xd7\x64\x05\x0c"
        "\x79\x14\xc1\x86\x8d\x48\x56\xa8\x1b\x27\x54\x88\xff\x53\x79\xb3"
        "\xd7\xdb\xcc\xad\xc3\xeb\xa2\xd2\xa1\xa3\x76\x9b\xb6\xdb\xdf\x29"
        "\x67\xf7\x37\xfb\xed\xeb\xac\xdd\x9a\x89\x09\xfa\x25\xcd\x9d\xa8"
        "\x89\x6d\xef\x21\x7a\xe9\xf4\x24\x08\x14\x7c\x3d\xea\xb2\x7c\xfc"
        "\x75\x8d\x06\x33\x38\x17\x8d\x8e\x71\xc0\x86\x8c\x83\xd4\x97\xcd"
        "\x39\xa3\x20\x4f\xd0\xf6\x1f\xb3\x6e\x08\x66\x6b\xfc\x00\x57\x69"
        "\xe3\xde\x64\x51\xe7\x4d\x27\xdc\x34\x8a\xf9\xdf\xdb\x97\x57\x82"
        "\xec\xbf\xa3\xac\xa8\xd8\x3a\x07\xa9\x18\xc9\xba\xbb\x06\x3a\xc6"
        "\xec\x53\x99\x86\x8c\x05\x46\xd9\x72\x0d\xc4\x04\xbe\x34\x0f\x49"
        "\x78\xda\xb0\xfa\x5e\x82\xcd\xa3\xd1\x64\xd8\x0b\xa8\x92\x99\x07"
        "\x66\x67\xf7\xe9\xb6\x4c\x72\x13\x55\xc9\x1e\x58\x13\xf6\xf6\x46"
        "\x0e\x49\xe9\x95\xd6\xfd\x14\xac\x5e\xe4\x4f\xd1\xad\x0b\x40\x73"
        "\xee\x2c\xf8\xad\xba\x09\x87\xc7\x5c\x92\xaa\xeb\xce\x3c\x65\x0c"
        "\x51\xf5\x60\xd0\xd1\x1b\x96\xd7\x1d\x7a\x4d\x11\xe5\x12\x31\x46"
        "\x2f\x64\xce\x9c\xb5\xe4\x8f\x17\x31\x00\xee\xe3\xc1\xf8\xaf\x62"
        "\x7f\xc5\x3f\xe4\x25\x25\x82\x8b\x31\x6c\x98\x06\xf5\x18\xc9\xea"
        "\xb7\x7b\xda\x3a\x76\x3f\x45\x56\xbe\x89\x14\x3f\xfa\x9b\x50\x70"
        "\xf5\x44\xff\x8d\x55\x0f\x66\x8c\xe1\x14\xf2\x55\x06\x6f\x68\xf2"
        "\xa9\xfa\x16\xa9\xa6\xcf\x4f\x47\xb1\x56\x35\x59\xb9\xf4\x16\x5e"
        "\x33\x30\xb7\xde\x4e\x5f\x38\xf7\x41\xfb\x94\xcc\xb7\x63\x61\xa6"
        "\xa2\xbd\xcb\x28\x6a\x7e\xc7\xa9\x43\x83\x52\x5e\xd5\x4c\x68\xcb"
        "\xab\x2f\xe2\xf5\xd2\x79\xbc\x44\x31\x93\x9b\x8f\x29\xfd\x60\x0a"
        "\x7c\xbb\x2b\x2f\xd1\x1e\x7c\xbc\x2e\x19\x00\xa3\x94\xd3\xd7\x3a"
        "\x53\xc3\xec\xe5\x53\xab\xfb\x00\x17\xe8\x4f\x37\x50\xfc\xd3\xd1"
        "\xf8\xe8\x8f\x30\xe6\x47\x41\xe4\x46\x96\xc7\x86\x0b\x55\xa8\x97"
        "\x60\x6c\x21\x42\x38\x24\xdd\x5e\x1e\xe3\x29\xc5\xdc\x83\xc3\xff"
        "\x34\x7f\xc2\xf3\xd8\x36\x55\x9d\x70\x5b\x32\xfd\x6e\x55\x8c\xa0"
        "\x90\xe0\xae\x92\x09\x3b\x0d\x62\x0e\xce\x1b\x67\x0e\x86\x27\x26"
        "\x86\xe7\x0c\xac\x34\x6c\x6c\x06\x02\xa1\x74\x53\x63\x1b\x42\x04"
        "\x40\x94\xf5\x3c\x42\xa9\x7d\xaf\xa1\xf3\x4f\xc7\x6c\xc3\x3b\x60"
        "\x20\xd6\xd9\x55\xb0\x0b\x5d\x00\x64\xfd\x21\x65\x8b\x9c\x24\x1b"
        "\x7b\x30\x46\x90\x34\x2c\xa6\xa3\x0a\xa2\xe6\x7a\xcf\xbf\xd1\xad"
        "\xa0\xee\xda\xc1\x3a\x73\x26\xef\x07\x3c\xee\x8d\xbf\x51\x6c\xb6"
        "\x2b\xff";
    memcpy(&pbuf, test2, sizeof(test2));
    n = decapsulate(&pbuf, sizeof(test2));
    assert(n == 1024);
    assert(pbuf.len == 1024);
    for (int i = 0, c = 0; i < n; i++)
    {
        c = (32771 * c + 10007) % 65537;
        assert((pbuf.payload[i]) == (c & 0xffu));
    }

    for (int len = 0; len <= mtu; len++)
    {
        for (int data = 0; data <=2; data++)
        {
            for (int j = 0; j < len; j++)
            {
                if (data == 0)
                {
                    pbuf.payload[j] = (uint8_t)(randombytes_uniform(256));
                }
                else if (data == 1)
                {
                    pbuf.payload[j] = (uint8_t)(j & 0xffU);
                }
                else
                {
                    pbuf.payload[j] = (uint8_t)(len & 0xffU);
                }
            }
            pbuf.len = len;
            pbuf.flag = 0x0000;
            pbuf.ack = 0;

            pbuf_t copy;
            copy.ack = pbuf.ack;
            copy.flag = pbuf.flag;
            copy.len = pbuf.len;
            memcpy(copy.payload, pbuf.payload, pbuf.len);

            n = encapsulate(&copy, mtu);
            assert(n <= mtu + PAYLOAD_OFFSET);

            n = decapsulate(&copy, n);
            assert(n >= 0);
            assert(copy.len == pbuf.len);
            assert(memcmp(copy.payload, pbuf.payload, copy.len) == 0);
        }
    }
    return 0;
}
